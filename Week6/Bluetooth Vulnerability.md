&nbsp;
---
&nbsp;

BlueBorne

<img width="963" height="617" alt="image" src="https://github.com/user-attachments/assets/eabde90a-cff1-45f1-a50d-a733ed464043" />

출처: Exploiting Blueborne in Linux-based IOT Devices - 2019 ARMIS

두 기기간의 Maximum Transition Unit 확정과정

1. A가 0x100 요청
2. B가 허용
3. B가 0x200 요청
4. A가 허용

이후, 성공적으로 과정이 이루어지면 CONF_MTU_DONE으로 마킹, 아니라면 UNACCEPTED 상태로 들어감.

```
static int l2cap_parse_conf_rsp (struct l2cap_chan *chan, void * rsp, int len, void * data, u16 *result){
  struct l2cap_conf_req * req = data;
  void * ptr = req- > data ;
  // ...
  while (len >= L2CAP_CONF_OPT_SIZE){
    len -= l2cap_get_conf_opt (& rsp , &type, &olen, & val );
    switch (type){
      case L2CAP_CONF_MTU:
        // Validate MTU...
        l2cap_add_conf_opt (& ptr , L2CAP_CONF_MTU, 2, chan->imtu );
        break;
      case L2CAP_CONF_FLUSH_TO:
        chan->flush_to = val;
        l2cap_add_conf_opt (& ptr , L2CAP_CONF_FLUSH_TO, 2, chan->flush_to );
        break;
      // ...
    }
  }
    // ...
    return ptr - data;
}
```

BlueZ의 configuration 과정에서, 상대의 response는 위와 같은 l2cap_parsse_conf_rsp() 함수를 통해 처리됨. 기본적으로, rsp의 모든 값을 data로 복사하게 됨.

```
switch (result) {
case L2CAP_CONF_SUCCESS :
  ...
  break ;

case L2CAP_CONF_PENDING :
  set_bit(CONF_REM_CONF_PEND, & chan -> conf_state);
  if (test_bit( CONF_LOC_CONF_PEND , & chan -> conf_state)) {
    char buf [64];
    len = l2cap_parse_conf_rsp (chan, rsp -> data , len, buf , & result);
    ...
  goto done;
```

그런데, lockstep Configuration process라고 하는 다른 과정도 있음. EFS (Extended Flow Specification)에서 사용됨. 
> EFS는 QoS 같은 기능을 제공하기 위한 장치. 데이터 송수신 우선순위 등을 조정해 연결 품질 관리를 함.
EFS에서는 특정 조건을 만족할 경우 바로 MTU 확정/거부를 하지 않고 'Pending' 상태로 진입함.

Success일 경우, 대체적으로 rsp를 응답하는데 큰 무리가 없지만, Pending일 경우 char[64]의 작은 용량 버퍼가 주어짐. <-- Buffer Overflow 가능성.

```
if (remote_efs) {
  if (chan -> local_stype != L2CAP_SERV_NOTRAFIC &&
    efs. stype != L2CAP_SERV_NOTRAFIC &&
    efs.stype != chan -> local_stype) {
  } else {
    /* Send PENDING Conf Rsp */
    result = L2CAP_CONF_PENDING;
    set_bit( CONF_LOC_CONF_PEND , & chan -> conf_state);
  }
}
```

BlueZ 내부적으로 EFS를 다루는 부분에서, 양 기기 중 한쪽이 NOTARAFFIC(데이터 전송할 계획이 없음)이거나, 둘의 stype이 동일한 경우 Pending으로 set 됨. 따라서, EFS 요청을 보낼 때 NOTRAFFIC으로 보내면 쉽게 상대 기기를 pending으로 set할 수 있음. 이 상태에서 Respose로 유효한 큰 값을 보내면 스택에 접근 가능. RCE, Memory Leakage등 다양한 문제 발생.

&nbsp;
---
&nbsp;

BleedingTooth


&nbsp;
---
&nbsp;

BrakTooth
