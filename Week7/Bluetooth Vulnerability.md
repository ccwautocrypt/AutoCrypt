BlueToolKit

Bluetooth Vulnerability 취약점 검사 도구

- Chaining
- DoS(Denial of Service)
- MitM(Man in the midle)
- RCE(Remote Conde Execution)
- Memory Leak

```
name: "bleedingtooth_badvibes_cve_2020_24490" 
author: "Google"
type: "DoS"
mass_testing: true
max_timeout: 20
attack_type: "NotAutomated"
bt_version_min: 1.0
bt_version_max: 5.2
hardware: "default"
command: "./poc_badvibes_cve_2020_24490"
parameters: []
log_pull:
  in_command: false
  pull_parameter: null
  from_directory: null
directory:
  change: true
  directory: "modules/tools/bleedingtooth/"
```

&nbsp;
---
&nbsp;

BlueBorne

Bluetooth 기능이 켜져있는 기기를 근거리에서 무선으로 공격하는 방법. l2cap에 접근.

<img width="963" height="617" alt="image" src="https://github.com/user-attachments/assets/eabde90a-cff1-45f1-a50d-a733ed464043" />

출처: Exploiting Blueborne in Linux-based IOT Devices - 2019 ARMIS

두 기기간의 Maximum Transition Unit 확정과정

1. A가 0x100 요청
2. B가 허용
3. B가 0x200 요청
4. A가 허용

이후, 성공적으로 과정이 이루어지면 CONF_MTU_DONE으로 마킹, 아니라면 UNACCEPTED 상태로 들어감.

```
static int l2cap_parse_conf_rsp (struct l2cap_chan *chan, void * rsp, int len, void * data, u16 *result){
  struct l2cap_conf_req * req = data;
  void * ptr = req- > data ;
  // ...
  while (len >= L2CAP_CONF_OPT_SIZE){
    len -= l2cap_get_conf_opt (& rsp , &type, &olen, & val );
    switch (type){
      case L2CAP_CONF_MTU:
        // Validate MTU...
        l2cap_add_conf_opt (& ptr , L2CAP_CONF_MTU, 2, chan->imtu );
        break;
      case L2CAP_CONF_FLUSH_TO:
        chan->flush_to = val;
        l2cap_add_conf_opt (& ptr , L2CAP_CONF_FLUSH_TO, 2, chan->flush_to );
        break;
      // ...
    }
  }
    // ...
    return ptr - data;
}
```

BlueZ의 configuration 과정에서, 상대의 response는 위와 같은 l2cap_parsse_conf_rsp() 함수를 통해 처리됨. 기본적으로, rsp의 모든 값을 data로 복사하게 됨.

```
switch (result) {
case L2CAP_CONF_SUCCESS :
  ...
  break ;

case L2CAP_CONF_PENDING :
  set_bit(CONF_REM_CONF_PEND, & chan -> conf_state);
  if (test_bit( CONF_LOC_CONF_PEND , & chan -> conf_state)) {
    char buf [64];
    len = l2cap_parse_conf_rsp (chan, rsp -> data , len, buf , & result);
    ...
  goto done;
```

그런데, lockstep Configuration process라고 하는 다른 과정도 있음. EFS (Extended Flow Specification)에서 사용됨. 
> EFS는 QoS 같은 기능을 제공하기 위한 장치. 데이터 송수신 우선순위 등을 조정해 연결 품질 관리를 함.
EFS에서는 특정 조건을 만족할 경우 바로 MTU 확정/거부를 하지 않고 'Pending' 상태로 진입함.

Success일 경우, 대체적으로 rsp를 응답하는데 큰 무리가 없지만, Pending일 경우 char[64]의 작은 용량 버퍼가 주어짐. <-- Buffer Overflow 가능성.

```
if (remote_efs) {
  if (chan -> local_stype != L2CAP_SERV_NOTRAFIC &&
    efs. stype != L2CAP_SERV_NOTRAFIC &&
    efs.stype != chan -> local_stype) {
  } else {
    /* Send PENDING Conf Rsp */
    result = L2CAP_CONF_PENDING;
    set_bit( CONF_LOC_CONF_PEND , & chan -> conf_state);
  }
}
```

BlueZ 내부적으로 EFS를 다루는 부분에서, 양 기기 중 한쪽이 NOTARAFFIC(데이터 전송할 계획이 없음)이거나, 둘의 stype이 동일한 경우 Pending으로 set 됨. 따라서, EFS 요청을 보낼 때 NOTRAFFIC으로 보내면 쉽게 상대 기기를 pending으로 set할 수 있음. 이 상태에서 Respose로 유효한 큰 값을 보내면 스택에 접근 가능. RCE, Memory Leakage등 다양한 문제 발생.

&nbsp;
---
&nbsp;

BleedingTooth

Bluetooth가 켜져있는 기기를 향해 공격자가 커널 권한을 탈취해 공격 가능.
- BadVibes: Heap Overflow를 이용한 구조체 덮어쓰기.
- BadChoiece: A2MP 구조체 일부 유출
- BadKarma: L2CAP/A2MP 채널의 참조 카운트 관리 오류로 타입 혼동 발생

```
static void hci_le_adv_report_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_advertising_info *ev = ptr;
		s8 rssi;

		if (ev->length <= HCI_MAX_AD_LENGTH) {
			rssi = ev->data[ev->length];
			process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
					   ev->bdaddr_type, NULL, 0, rssi,
					   ev->data, ev->length);
		} else {
			bt_dev_err(hdev, "Dropping invalid advertising data");
		}

		ptr += sizeof(*ev) + ev->length + 1;
	}

	hci_dev_unlock(hdev);
}
...
static void hci_le_ext_adv_report_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_ext_adv_report *ev = ptr;
		u8 legacy_evt_type;
		u16 evt_type;

		evt_type = __le16_to_cpu(ev->evt_type);
		legacy_evt_type = ext_evt_type_to_legacy(hdev, evt_type);
		if (legacy_evt_type != LE_ADV_INVALID) {
			process_adv_report(hdev, legacy_evt_type, &ev->bdaddr,
					   ev->bdaddr_type, NULL, 0, ev->rssi,
					   ev->data, ev->length);
		}

		ptr += sizeof(*ev) + ev->length;
	}

	hci_dev_unlock(hdev);
}
```
BadVibes: 확장 광고에서 길이 검사가 없음. 위쪽 함수와 달리 아래쪽 확장 광고는 HCI_MAX_AD_LENGTH 와의 길이 비교가 없음.

```
static int a2mp_getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb,
			    struct a2mp_cmd *hdr)
{
	struct a2mp_info_req *req  = (void *) skb->data;
	...
	hdev = hci_dev_get(req->id);
	if (!hdev || hdev->dev_type != HCI_AMP) {
		struct a2mp_info_rsp rsp;

		rsp.id = req->id;
		rsp.status = A2MP_STATUS_INVALID_CTRL_ID;

		a2mp_send(mgr, A2MP_GETINFO_RSP, hdr->ident, sizeof(rsp),
			  &rsp);

		goto done;
	}
	...
}
```
BadChoice: a2mp_getinfo_req() 처리 시, 유효하지 않으면 현재 상태를 반환함. 그런데, 이 과정에서 일부 스택 데이터가 쵸기화되지 않음. 공격자는 이 함수 호출시 사용되는 포인터 부분에 강제로 어떤 주소를 삽입해 원하는 결과를 유도해 낼 수도 있음.

이 과정을 통해 l2cap_chan의 위치 노출

l2cap_chan 해제

Heap Spraying으로 원하는 데이터 무작위로 뿌리기

이후 A2MP 연결 종료 --> l2cap_chan 호출. (이미 없는데)

결과적으로 free 한 주소에 원하는 vulnerable한 주소가 들어가게 됨.


&nbsp;
---
&nbsp;

이 외의 주요 취약점 부분들...

BrakTooth: Heap Overflow를 통해해 DoS 등 유발

Reconnaissance attacks

암호화 검사...
